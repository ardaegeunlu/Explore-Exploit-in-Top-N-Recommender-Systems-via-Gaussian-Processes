# Explore-Exploit-in-Top-N-Recommender-Systems-via-Gaussian-Processes

A simple MATLAB Implementation of CGP-RANK algorithm [1]. CGP-RANK ranks an ordered list of recommendations, and it is a well suited algorithm for web-scale tasks, where the number of items available for recommendation is too large, and the context space too complex, compared to the relatively sparse click feedback.

CGP-RANK is an upper-confidence style algorithm, which exploits prior information specified in terms of a Gaussian process kernel function, which allows to share feedback in three ways: between positions in a list, between items, and between contexts [2]. Choice of kernels expresses our prior assumption of how smoothly the rewards change over the item-context space, and allows us to predict the performance of yet unexplored lists using Gaussian Process models.

## Dependencies

You need to have the following libraries.
```
GPML Matlab Code version 4.2
```
[You can download it here!](http://www.gaussianprocess.org/gpml/code/matlab/doc/) Don't forget to add the library with all its subfolders to your project path.

## How to Run

You will need to initialize a couple things, let's walk through them one by one!

### Create a Reward Function
We will pass this function's handle to CGP-RANK, reward function should take as arguments a list of items and contexts, they can be multidimensional, as long as your kernels support it.

Let's first test with a very simple reward function, reward = sin(item) + cos(context) + noise.
```matlab
function reward = feedback_function(items, contexts)
    X = items;
    Y = contexts;
    reward = sin(X) + cos(Y);
    noise = randn(size(reward))*0.01;
    reward = (reward + noise)';
end
```

### Determine an Item List and Context for each Round 

You must also create a function that can tell which items are available in any given round t, if all items are always available you can simply return the whole list of items at every round. For this test, we choose our item domain from -3 to 3 with 0.05 intervals, and at every round t only a randomly selected 1/4 of all items will be available for recommendation.

```matlab
function item_list = available_item_list_creator(t)
    items = -3:0.05:3;
    item_list = datasample(items, int8(length(items)/4), 'Replace', false);
end
```

Similarly a random context will be selected at each round.

```matlab
function context = context_creator(t)
    contexts = -3:0.05:3;
    context = datasample(contexts, 1);
end
```

### Create Item & Context Kernels, Combine them and Set their Hyperparameters

Define a kernel using GPML Kernels, there is probably a kernel for your needs. If not, you can always create a custom one using covDiscrete, it is entirely possible to create diffusion kernels from graphs as used in the CGP-RANK paper by using GPML kernel functions, [check the documentation here!] (http://www.gaussianprocess.org/gpml/code/matlab/doc/manual.pdf) 

For this simple reward function, we will use isotropic squared exponential kernels without scaling.

```matlab
item_kernel = {@covSEisoU}; item_hyp = 0; 
mask = [1,0]; % binary mask so that this kernel applies only to items
item_kernel_masked = {@covMask,{mask,item_kernel}};

context_kernel = {@covSEisoU}; context_hyp = 0; 
mask = [0,1]; % binary mask so that this kernel applies only to contexts
context_kernel_masked = {@covMask,{mask,context_kernel}}; 

% product of two seperate kernels to create one composite kernel
kernel ={@covProd,{item_kernel_masked, context_kernel_masked}};
GP_hyperparameters.cov = [item_hyp, context_hyp];
```

### Initialize and Run
```matlab
% Total number of rounds
T = 40;
% number of items to be recommended in each round
batch_size = 5;
% f handles
context_receiver_handle = @context_creator;
available_item_list_receiver_handle = @available_item_list_creator;
feedback_handle = @feedback_function;
% calculate the optimal recommendation list for regret plots, this is an optional argument
calculate_optimal_rewards = true;

% Run!
[item_choices, observations, oracle] = CGPRank(kernel, GP_hyperparameters,...
    batch_size, T, context_receiver_handle, available_item_list_receiver_handle, ...
    feedback_handle, calculate_optimal_rewards);
```

## Some Tests and Plots
CGP-UCB is iterated for 300 learning rounds using the DummyEnvironment given above.
### Regret Plot
The following code plots the regret. Note that plot_regret is not a part of the CGP-UCB class.
```python
plot_regret(best=best_strategy_rewards, agent=agent.Y)
```
The sublinear regret shows that the CGP-UCB converges to the best action-context pair. 
![](https://github.com/ardaegeunlu/Contextual-Gaussian-Process-Bandit-Optimization/blob/master/plots/regret_300.png "Regret Plot")
